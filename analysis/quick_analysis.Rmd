---
title: "Quick analysis of C084"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: WEHI SCORE
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(rmarkdown)
library(janitor)
library(BiocStyle)
library(ggplot2)
library(cowplot)
source(here("code", "helper_functions.R"))
# NOTE: Using >= 4 cores seizes up my laptop. Can use more on RStudio server.
options(
  "mc.cores" = ifelse(gsub("^rstudio-[0-9]+", "", Sys.info()[["nodename"]]) ==
                        ".hpc.wehi.edu.au", 8L, 2L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(fig.path = "C084_Hayman_Pasricha_quick_analysis_files/")
```

# Setting up the data

```{r}
sce <- readRDS(
  here("data", "SCEs", "C084_Hayman_Pasricha.not_UMI_deduped.scPipe.SCE.rds"))
```

## Incorporating cell-based annotation

```{r}
new_colData <- DataFrame(
  plate_number = factor(
    sce$plate_number,
    c("LCE475", "LCE_476_BU_8_cycle", "C084_LC475_mini_bulk_back_up_1:10")),
  well_position = sce$well_position,
  rpi = sce$illumina_index_index_number_separate_index_read,
  well_position_in_original_dilution_layout =
    sce$well_position_in_original_dilution_layout,
  sequencing_run = sce$sequencing_run,
  id = factor(sce$id),
  group = factor(sce$group, levels = c("C", "B", "A")),
  collection_date = sce$collection_date,
  sample_serum = sce$sample_serum,
  rna = sce$rna,
  cytof_1 = sce$cytof_1,
  cytof_2 = sce$cytof_2,
  location_box = factor(sce$location_box),
  position = sce$position,
  timepoint = sce$timepoint,
  UMI_deduped = sce$UMI_deduped,
  regimen = factor(
    dplyr::case_when(
      sce$group == "A" ~ "high_zinc_low_iron_mnp",
      sce$group == "B" ~ "zinc_10mg_tab", 
      sce$group == "C" ~ "placebo"),
    levels = c("placebo", "zinc_10mg_tab", "high_zinc_low_iron_mnp")),
  row.names = colnames(sce))

colData(sce) <- new_colData
```

```{r}
# Some useful colours
plate_number_colours <- setNames(
  RColorBrewer::brewer.pal(nlevels(sce$plate_number), "Set2"),
  levels(sce$plate_number))
regimen_colours <- setNames(
  RColorBrewer::brewer.pal(nlevels(sce$regimen), "Accent"),
  levels(sce$regimen))
location_box_colours <- setNames(
  RColorBrewer::brewer.pal(nlevels(sce$location_box), "Set1"),
  levels(sce$location_box))
timepoint_colours <- setNames(
  RColorBrewer::brewer.pal(3, "Dark2")[1:2],
  levels(sce$timepoint))
```

### Summarising the data

```{r breakdown-by-plate-number, fig.asp = 1 / 2, layout = "l-body-outset", fig.cap = "Breakdown of the samples by plate."}
plot_grid(
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = regimen),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = regimen_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = location_box),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = location_box_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = timepoint),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = timepoint_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(aes(x = plate_number, fill = plate_number)) +
    coord_flip() +
    ylab("Number of wells") +
    scale_fill_manual(values = plate_number_colours) +
    theme_cowplot(font_size = 6),
  align = "v",
  ncol = 1)
```

```{r}
paged_table(.adf(colData(sce)))
```

## Incorporating gene-based annotation

```{r}
library(AnnotationHub)
library(ensembldb)
ah <- AnnotationHub()
EnsDb.Hsapiens.v94 <- ah[["AH64923"]]
ensembl <- gsub("\\.[0-9]+$", "", rownames(sce))
symb <- mapIds(
  x = EnsDb.Hsapiens.v94,
  # NOTE: Need to remove gene version number prior to lookup.
  keys = ensembl,
  keytype = "GENEID",
  column = "SYMBOL")
rowData(sce)$ENSEMBL <- ensembl
rowData(sce)$SYMBOL <- symb
# Replace the row names of the SCE by the gene symbols (where available).
library(scater)
rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$SYMBOL)
# Add chromosome location so we can filter on mitochondrial genes.
location <- mapIds(
  x = EnsDb.Hsapiens.v94,
  # NOTE: Need to remove gene version number prior to lookup.
  keys = rowData(sce)$ENSEMBL,
  keytype = "GENEID",
  column = "SEQNAME")
rowData(sce)$CHR <- location
```

# Quality control of cells

## Defining the quality control metrics

```{r, results = "hide"}
is_mito <- rowData(sce)$CHR == "MT"
summary(is_mito)
sce <- addPerCellQC(sce, subsets = list(Mt = which(is_mito)))
```

## Visualizing the QC metrics

```{r, layout = "l-page", fig.asp = 2 / 3}
plot_grid(
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number,
      y = sum)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number,
      y = altexps_ERCC_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number,
      y = detected)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number,
      y = subsets_Mt_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ncol = 2,
  align = "v")
```

```{r, fig.width = 10, fig.asp = 0.5}
par(mfrow = c(1, 3))
plot(
  x = sce$detected, 
  y = sce$sum / 1e3,
  xlab = "Number of expressed genes",
  ylab = "Library size (thousands)")
plot(
  x = sce$detected,
  y = sce$altexps_ERCC_percent, 
  xlab = "Number of expressed genes",
  ylab = "ERCC proportion (%)",
  ylim = c(0, 100))
plot(
  x = sce$detected, 
  y = sce$subsets_Mt_percent,
  xlab = "Number of expressed genes",
  ylab = "Mitochondrial proportion (%)",
  ylim = c(0, 100))
```

## Identifying outliers by each metric

```{r}
libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number,
  subset = sce$plate_number %in% c(
    "LCE_476_BU_8_cycle",
    "C084_LC475_mini_bulk_back_up_1:10"))
libsize_drop_thresholds <- attributes(libsize_drop)$thresholds["lower", ]
feature_drop <- isOutlier(
  metric = sce$detected, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number,
  subset = sce$plate_number %in% c(
    "LCE_476_BU_8_cycle",
    "C084_LC475_mini_bulk_back_up_1:10"))
feature_drop_thresholds <- attributes(feature_drop)$thresholds["lower", ]
spike_drop <- isOutlier(
  metric = sce$altexps_ERCC_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number,
  subset = sce$plate_number %in% c(
    "LCE_476_BU_8_cycle",
    "C084_LC475_mini_bulk_back_up_1:10"))
spike_drop_thresholds <- attributes(spike_drop)$thresholds["higher", ]
mito_drop <- isOutlier(
  metric = sce$subsets_Mt_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number,
  subset = sce$plate_number %in% c(
    "LCE_476_BU_8_cycle",
    "C084_LC475_mini_bulk_back_up_1:10"))
mito_drop_thresholds <- attributes(mito_drop)$thresholds["higher", ]
```

```{r}
libsize_drop_df <- data.frame(
  plate_number = colnames(attributes(libsize_drop)$thresholds),
  lower = attributes(libsize_drop)$thresholds["lower", ])
feature_drop_df <- data.frame(
  plate_number = colnames(attributes(feature_drop)$thresholds),
  lower = attributes(feature_drop)$thresholds["lower", ])
spike_drop_df <- data.frame(
  plate_number = colnames(attributes(spike_drop)$thresholds),
  lower = attributes(spike_drop)$thresholds["higher", ])
mito_drop_df <- data.frame(
  plate_number = colnames(attributes(mito_drop)$thresholds),
  lower = attributes(mito_drop)$thresholds["higher", ])
qc_cutoffs_df <- Reduce(
  function(x, y) dplyr::inner_join(x, y, by = "plate_number"),
  list(libsize_drop_df, feature_drop_df, spike_drop_df, mito_drop_df))
colnames(qc_cutoffs_df) <- c(
  "plate_number", "total counts", "total features", "%ERCC", "%mito")
qc_cutoffs_df %>%
  knitr::kable(caption = "QC cutoffs", digits = 1)
```

```{r}
sce_pre_QC_outlier_removal <- sce
keep <- !(libsize_drop | feature_drop | spike_drop | mito_drop)
sce <- sce[, keep]
```

```{r}
data.frame(
  ByLibSize = tapply(
    libsize_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum),
  ByFeature = tapply(
    feature_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum), 
  BySpike = tapply(
    spike_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum,
    na.rm = TRUE),
  ByMito = tapply(
    mito_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum,
    na.rm = TRUE),
  Remaining = as.vector(unname(table(sce$plate_number))),
  PercRemaining = round(
    100 * as.vector(unname(table(sce$plate_number))) /
      as.vector(
        unname(
          table(sce_pre_QC_outlier_removal$plate_number))), 1)) %>%
  tibble::rownames_to_column("plate_number") %>%
  dplyr::arrange(desc(PercRemaining)) %>%
  knitr::kable(
    caption = "Number of samples removed by each QC step and the number of samples remaining, ordered by the percentage of cells remaining.")
```

### Summary

```{r, layout = "l-page", fig.asp = 2 / 3}
sce_pre_QC_outlier_removal$keep <- keep
plot_grid(
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(
      x = plate_number,
      y = sum)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1, aes(colour = keep)) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(
      x = plate_number,
      y = altexps_ERCC_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1, aes(colour = keep)) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(
      x = plate_number,
      y = detected)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1, aes(colour = keep)) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(
      x = plate_number,
      y = subsets_Mt_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1, aes(colour = keep)) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ncol = 2,
  align = "v")
```

```{r}
plot_grid(
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = regimen),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = regimen_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = location_box),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = location_box_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(
      aes(x = plate_number, fill = timepoint),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = timepoint_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) +
    geom_bar(aes(x = plate_number, fill = plate_number)) +
    coord_flip() +
    ylab("Number of wells") +
    scale_fill_manual(values = plate_number_colours) +
    theme_cowplot(font_size = 6),
  align = "v",
  ncol = 1)
```

# Examining gene-level metrics

## Inspecting the most highly expressed genes

```{r, fig.asp = 1}
plotHighestExprs(sce, n = 50)
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "placebo" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("placebo.baseline")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "placebo" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("placebo.endline")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "zinc_10mg_tab" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("zinc_10mg_tab.baseline")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "zinc_10mg_tab" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("zinc_10mg_tab.endline")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "high_zinc_low_iron_mnp" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("high_zinc_low_iron_mnp.baseline")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[, sce$regimen == "high_zinc_low_iron_mnp" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("high_zinc_low_iron_mnp.endline")
```

```{r, fig.asp = 1}
plotHighestExprs(sce[!grepl("^MT|^RPS|^RPL", rownames(sce)), ], n = 50) +
  ggtitle("Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "placebo" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("placebo.baseline: Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "placebo" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("placebo.endline: Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "zinc_10mg_tab" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("zinc_10mg_tab.baseline: Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "zinc_10mg_tab" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("zinc_10mg_tab.endline: Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "high_zinc_low_iron_mnp" & sce$timepoint == "baseline"],
  n = 50) +
  ggtitle("high_zinc_low_iron_mnp.baseline: Excluding mitochondrial and ribosomal protein genes")
```

```{r, fig.asp = 1}
plotHighestExprs(
  sce[!grepl("^MT|^RPS|^RPL", rownames(sce)),
      sce$regimen == "high_zinc_low_iron_mnp" & sce$timepoint == "endline"],
  n = 50) +
  ggtitle("high_zinc_low_iron_mnp.endline: Excluding mitochondrial and ribosomal protein genes")
```

## Filtering out low-abundance genes

```{r abhist, fig.cap = "Histogram of log-average counts for all genes in the combined data set.", results = "hide"}
ave_counts <- calculateAverage(sce)
par(mfrow = c(1, 1))
hist(
  x = log10(ave_counts), 
  breaks = 100, 
  main = "", 
  col = "grey",
  xlab = expression(Log[10] ~ "Cverage count"))
to_keep <- ave_counts > 0
sce <- sce[to_keep, ]
```

We remove `r sum(!to_keep)` genes that are not expressed in any cell.
Such genes provide no information and would be removed by any filtering strategy.
We retain `r sum(to_keep)` for downstream analysis.

# Normalization of cell-specific biases

**TODO:** Try other size factors (e.g., `edgeR::calcNormFactors()`)

## Using the deconvolution method to deal with zero counts

```{r, results = "hide"}
library(scran)
set.seed(37610)
clusters <- quickCluster(sce)
table(sce$plate_number, clusters)
sce <- computeSumFactors(sce, min.mean = 0.1)
summary(sizeFactors(sce))
```

```{r, results = "hide", fig.asp = 1 / 2, layout = "l-page"}
xlim <- c(100, max(sce$sum) / 1e3)
ylim <- range(sizeFactors(sce))
par(mfrow = c(1, 2))
lapply(levels(factor(sce$plate_number)), function(p) {
  sce <- sce[, sce$plate_number == p]
  plot(
    x = sce$sum / 1e3, 
    y = sizeFactors(sce), 
    log = "xy",
    xlab = "Library size (thousands)", 
    ylab = "Size factor",
    main = p,
    xlim = xlim,
    ylim = ylim,
    pch = 16)
})
```

## Applying the size factors to normalize gene expression

```{r}
sce <- logNormCounts(sce)
```

## Computing separate size factors for spike-in transcripts

```{r}
sizeFactors(altExp(sce)) <- librarySizeFactors(altExp(sce))
```

# Batch correction

Here, we will treat each plate as a 'batch', i.e. `r nlevels(sce$plate_number)` batches in total.

```{r}
# NOTE: Can reuse plate colours
batch_colours <- plate_number_colours
sce$batch <- factor(sce$plate_number)
```

# Feature selection

## Motivation

## Quantifying per-gene variation

### Variance of the log-counts

### Quantifying technical noise

### Accounting for blocking factors

```{r}
dec <- modelGeneVar(sce, block = sce$batch)
```

```{r, results = "hide", fig.asp = 1 / 2, layout = "l-page"}
xlim <- c(0, max(sapply(dec$per.block, function(x) max(x$mean))))
ylim <- c(0, max(sapply(dec$per.block, function(x) max(x$total))))
par(mfrow = c(1, 2))
blocked_stats <- dec$per.block
for (i in seq_len(ncol(blocked_stats))) {
  current <- blocked_stats[[i]]
  plot(
    current$mean,
    current$total,
    main = names(blocked_stats)[i],
    pch = 16,
    cex = 0.5,
    xlab = "Mean of log-expression",
    ylab = "Variance of log-expression",
    xlim = xlim,
    ylim = ylim)
  curfit <- metadata(current)
  curve(curfit$trend(x), col = batch_colours[[i]], add = TRUE, lwd = 2) 
}
```

```{r trendplots-fits, fig.cap = "Cn overlay of the trend fits from the previous figure, highlighting the need for the batch-specific trend fits. Each line is a the trend line for a particular batch (with colours matching the previous plot).", results = "hide", fig.asp = 1}
par(mfrow = c(1, 1))
# NOTE: 'Fake' plot with right dimensions to overlay trends.
plot(
  x = current$mean, 
  y = current$total, 
  pch = 0,
  cex = 0.6, 
  xlab = "Mean log-expression", 
  ylab = "Variance of log-expression", 
  main = "Trends", 
  xlim = xlim, 
  ylim = ylim,
  col = "white")
lapply(seq_len(ncol(blocked_stats)), function(b) {
  curve(
    metadata(dec$per.block[[b]])$trend(x), 
    col = batch_colours[b], 
    lwd = 1, 
    add = TRUE)
})
legend(
  "topright", 
  legend = levels(sce$batch), 
  col = batch_colours,
  lwd = 1,
  title = "Plate number",
  ncol = 1,
  cex = 0.8)
```

## Selecting highly variable genes

```{r}
hvg <- getTopHVGs(dec, var.threshold = 0)
```

There are `r length(hvg)` HVGs by this approach.

```{r}
library(scater)
plotExpression(object = sce, features = hvg[1:10])
```

# Dimensionality reduction

## Principal component analysis

```{r}
sce <- denoisePCA(sce, technical = dec, subset.row = hvg)
```

This retains `r ncol(reducedDim(sce, "PCA"))` dimensions.

# Batch correction with MNN

**TODO:** Try MNN

## Algorithm overview

## Application

```{r, results = "hide", eval = FALSE}
library(batchelor)
mnn_out <- fastMNN(
  multiBatchNorm(sce, batch = factor(sce$plate_number)),
  batch = sce$plate_number,
  cos.norm = FALSE,
  d = ncol(reducedDim(sce, "PCA")),
  auto.merge = TRUE,
  subset.row = hvg)
metadata(mnn_out)$merge.info
metadata(mnn_out)$merge.info$lost.var
```

```{r, eval = FALSE}
reducedDim(sce, "corrected") <- reducedDim(mnn_out)
```

```{r}
library(batchelor)
rescaled <- rescaleBatches(sce, batch = factor(sce$plate_number))
```

```{r}
set.seed(1010101010) 
rescaled <- runPCA(rescaled, subset_row = hvg, exprs_values = "corrected")

snn.gr <- buildSNNGraph(rescaled, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr)$membership
table(Cluster=clusters, Batch=rescaled$batch)
```

```{r}
reducedDim(sce, "corrected") <- t(assay(rescaled, "corrected"))
```

# Visual inspection of merge results

```{r}
uncorrected_pca <- cbind(
  data.frame(
    x = reducedDim(sce, "PCA")[, 1],
    y = reducedDim(sce, "PCA")[, 2]),
  as.data.frame(colData(sce)))
ggplot(aes(x = x, y = y), data = uncorrected_pca) +
  geom_point(aes(colour = plate_number), size = 1) +
  scale_colour_manual(values = plate_number_colours) +
  cowplot::theme_cowplot(font_size = 10) + 
  ggtitle("Original") +
  xlab("PC 1") + 
  ylab("PC 2")
```

```{r}
plotPCA(sce, ncomponents = 5, colour_by = "plate_number") + 
  ggtitle("Original")
```

```{r}
plotPCA(rescaled, ncomponents = 5, colour_by = "batch") + 
  ggtitle("Corrected")
```

```{r, eval = FALSE}
set.seed(572968)
uncorrected <- runUMAP(sce, dimred = "PCA")
uncorrected_umap <- cbind(
  data.frame(
    x = reducedDim(uncorrected, "UMAP")[, 1],
    y = reducedDim(uncorrected, "UMAP")[, 2]),
  as.data.frame(colData(uncorrected)))
ggplot(aes(x = x, y = y), data = uncorrected_umap) +
  geom_point(aes(colour = plate_number), size = 1) +
  scale_colour_manual(values = plate_number_colours) +
  cowplot::theme_cowplot(font_size = 10) + 
  ggtitle("Original") +
  xlab("Dimension 1") + 
  ylab("Dimension 2")
```

```{r, eval = FALSE}
set.seed(55788)
sce <- runUMAP(sce, dimred = "corrected")
corrected_umap <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)))
ggplot(aes(x = x, y = y), data = corrected_umap) +
  geom_point(aes(colour = plate_number), size = 1) +
  scale_colour_manual(values = plate_number_colours) +
  cowplot::theme_cowplot(font_size = 10) + 
  ggtitle("Corrected") +
  xlab("Dimension 1") + 
  ylab("Dimension 2")
```

# DE analysis

```{r}
library(edgeR)
y <- DGEList(counts(sce), samples = colData(sce))
y$samples$plate_number <- factor(y$samples$plate_number)
discarded <- isOutlier(y$samples$lib.size, log = TRUE, type = "lower", nmads = 3)
y <- y[, !discarded]
y$samples$g <- paste0(y$samples$regimen, ".", y$samples$timepoint)
design <- model.matrix(~0 + g + plate_number, data = y$samples)
colnames(design) <- sub("^g|plate_number", "", colnames(design))
colnames(design) <- sub(
  "C084_LC475_mini_bulk_back_up_1:10",
  "plate_1_in_10",
  colnames(design))
keep <- filterByExpr(y, design = design)
table(keep)
y <- y[keep, ]
y <- calcNormFactors(y)

y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust = TRUE)

my_contrasts <- makeContrasts(
  placebo.endline_vs_baseline = placebo.endline - placebo.baseline,
  zinc_10mg_tab.endline_vs_baseline = zinc_10mg_tab.endline - 
    zinc_10mg_tab.baseline,
  high_zinc_low_iron_mnp.endline_vs_baseline = 
    high_zinc_low_iron_mnp.endline - 
    high_zinc_low_iron_mnp.baseline,
  levels = design)
```

## placebo.endline_vs_baseline

```{r}
qlf_placebo <- glmQLFTest(fit, contrast = my_contrasts[, "placebo.endline_vs_baseline"])
summary(decideTests(qlf_placebo))
rmarkdown::paged_table(as.data.frame(topTags(qlf_placebo, n = Inf, p.value = 0.05)))
```

```{r}
tt_placebo <- topTags(qlf_placebo, n = Inf, p.value = 0.05)
pdf(here("output", "figures", "C.endline_vs_baseline.pdf"))
for (i in seq_len(nrow(tt_placebo))) {
  message(i)
  g <- rownames(tt_placebo)[i]
  p <- plotExpression(
    sce,
    g,
    x = I(paste0(sce$regimen, ".", sce$timepoint)), colour_by = "timepoint",
    other_fields = "plate_number") + 
    facet_grid(~ plate_number) +
    ggtitle(
      paste0(
        g,
        " (FDR = ", 
        signif(tt_placebo[g, "FDR"][[1]], 1),
        ")")) +
    stat_summary(
      fun.data = "mean_cl_boot",
      geom = "crossbar",
      colour = "red",
      width = 0.3) + 
    cowplot::theme_cowplot() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.background = element_blank(),
      strip.text.x = element_blank())
  print(p)
}
dev.off()
```

## zinc_10mg_tab.endline_vs_baseline

```{r}
qlf_zinc_10mg_tab <- glmQLFTest(fit, contrast = my_contrasts[, "zinc_10mg_tab.endline_vs_baseline"])
summary(decideTests(qlf_zinc_10mg_tab))
rmarkdown::paged_table(as.data.frame(topTags(qlf_zinc_10mg_tab, n = Inf, p.value = 0.05)))
```

```{r}
tt_zinc_10mg_tab <- topTags(qlf_zinc_10mg_tab, n = Inf, p.value = 0.05)
pdf(here("output", "figures", "zinc_10mg_tab.endline_vs_baseline.pdf"))
for (i in seq_len(nrow(tt_zinc_10mg_tab))) {
  message(i)
  g <- rownames(tt_zinc_10mg_tab)[i]
  p <- plotExpression(
    sce,
    g,
    x = I(paste0(sce$regimen, ".", sce$timepoint)), colour_by = "timepoint",
    other_fields = "plate_number") + 
    facet_grid(~ plate_number) +
    ggtitle(
      paste0(
        g,
        " (FDR = ", 
        signif(tt_zinc_10mg_tab[g, "FDR"][[1]], 1),
        ")")) +
    stat_summary(
      fun.data = "mean_cl_boot",
      geom = "crossbar",
      colour = "red",
      width = 0.3) + 
    cowplot::theme_cowplot() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.background = element_blank(),
      strip.text.x = element_blank())
  print(p)
}
dev.off()
```

## high_zinc_low_iron_mnp.endline_vs_baseline

```{r}
qlf_high_zinc_low_iron_mnp <- glmQLFTest(fit, contrast = my_contrasts[, "high_zinc_low_iron_mnp.endline_vs_baseline"])
summary(decideTests(qlf_high_zinc_low_iron_mnp))
rmarkdown::paged_table(as.data.frame(topTags(qlf_high_zinc_low_iron_mnp, n = Inf, p.value = 0.05)))
```

```{r}
tt_high_zinc_low_iron_mnp <- topTags(qlf_high_zinc_low_iron_mnp, n = Inf, p.value = 0.05)
pdf(here("output", "figures", "high_zinc_low_iron_mnp.endline_vs_baseline.pdf"))
for (i in seq_len(nrow(tt_high_zinc_low_iron_mnp))) {
  message(i)
  g <- rownames(tt_high_zinc_low_iron_mnp)[i]
  p <- plotExpression(
    sce,
    g,
    x = I(paste0(sce$regimen, ".", sce$timepoint)), colour_by = "timepoint",
    other_fields = "plate_number") + 
    facet_grid(~ plate_number) +
    ggtitle(
      paste0(
        g,
        " (FDR = ", 
        signif(tt_high_zinc_low_iron_mnp[g, "FDR"][[1]], 1),
        ")")) +
    stat_summary(
      fun.data = "mean_cl_boot",
      geom = "crossbar",
      colour = "red",
      width = 0.3) + 
    cowplot::theme_cowplot() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      strip.background = element_blank(),
      strip.text.x = element_blank())
  print(p)
}
dev.off()
```

## Summary

```{r}
tmp <- cbind(
    decideTests(qlf_placebo), 
    decideTests(qlf_zinc_10mg_tab),
    decideTests(qlf_high_zinc_low_iron_mnp))
colnames(tmp) <- c("placebo", "zinc_10mb_tab", "high_zinc_log_iron_mnp")
vennDiagram(tmp)
```

```{r}
g <- unique(c(rownames(tt_placebo), rownames(tt_zinc_10mg_tab), rownames(tt_high_zinc_low_iron_mnp)))
```

```{r}
dev.off() # NOTE: Needed for next figure to print correctly
pdf(here("output", "figures", "DEGs.heatmap.pdf"), height = 12, width = 9)
plotHeatmap(
  sce,
  features = g,
  center = TRUE,
  zlim = c(-3, 3),
  colour_columns_by = c("plate_number", "regimen", "timepoint"),
  order_columns_by  = c("plate_number", "regimen", "timepoint"),
  cluster_cols = FALSE)
dev.off()
```

```{r}
dev.off() # NOTE: Needed for next figure to print correctly
pdf(
  here("output", "figures", "DEGs.heatmap.LCE_476_BU_8_cycle.pdf"),
  height = 12, 
  width = 9)
plotHeatmap(
  sce[, sce$plate_number == "LCE_476_BU_8_cycle"],
  features = g,
  center = TRUE,
  zlim = c(-3, 3),
  colour_columns_by = c("regimen", "timepoint"),
  order_columns_by  = c("regimen", "timepoint"),
  cluster_cols = FALSE,
  main = "LCE_476_BU_8_cycle")
dev.off()
```

```{r}
dev.off() # NOTE: Needed for next figure to print correctly
pdf(
  here(
    "output",
    "figures",
    "DEGs.heatmap.C084_LC475_mini_bulk_back_up_1_in_10.pdf"),
  height = 12, 
  width = 9)
plotHeatmap(
  sce[, sce$plate_number == "C084_LC475_mini_bulk_back_up_1:10"],
  features = g,
  center = TRUE,
  zlim = c(-3, 3),
  colour_columns_by = c("regimen", "timepoint"),
  order_columns_by  = c("regimen", "timepoint"),
  cluster_cols = FALSE,
  main = "C084_LC475_mini_bulk_back_up_1:10")
dev.off()
```

```{r, eval = FALSE}
rescaled$plate_number <- sce$plate_number
rescaled$regimen <- sce$regimen
rescaled$timepoint <- sce$timepoint
plotHeatmap(
  rescaled,
  exprs_values = "corrected",
  features = g,
  center = TRUE,
  zlim = c(-3, 3),
  colour_columns_by = c("plate_number", "regimen", "timepoint"))
```

```{r, eval = FALSE}
rescaled$plate_number <- sce$plate_number
rescaled$regimen <- sce$regimen
rescaled$timepoint <- sce$timepoint
plotHeatmap(
  rescaled,
  exprs_values = "corrected",
  features = g,
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-3, 3),
  colour_columns_by = c("plate_number", "regimen", "timepoint"),
  order_columns_by  = c("plate_number", "regimen", "timepoint"),
  cluster_cols = FALSE)
```

## Glimma

**TODO:** Glimma MDS and MA plots

# TODO

- [ ] Pairwise plots of logcounts for each sample to compare the two batches
